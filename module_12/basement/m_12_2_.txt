Импорт необходимых модулей:

from runner import Runner, Tournament
import unittest
Здесь мы импортируем классы Runner и Tournament из модуля runner, а также модуль unittest, который используется для создания и запуска тестов.

Определение класса теста:

class TournamentTest(unittest.TestCase):
Создаем класс TournamentTest, который наследует от unittest.TestCase. Это означает, что мы будем использовать функциональность unittest для написания тестов.

Класс-метод для подготовки тестов:

@classmethod
def setUpClass(cls):
    cls.all_results = {}
setUpClass вызывается один раз перед запуском тестов. Здесь инициализируется словарь all_results, который будет хранить результаты всех гонок.

Метод для подготовки окружения перед каждым тестом:

def setUp(self):
    self.runner1 = Runner("Усэйн", speed=10)
    self.runner2 = Runner("Андрей", speed=9)
    self.runner3 = Runner("Ник", speed=3)
setUp выполняется перед каждым тестом. Здесь мы создаем три объекта типа Runner с различными именами и скоростями.

Метод для очистки после всех тестов:

@classmethod
def tearDownClass(cls):
    for result in cls.all_results.values():
        print(result)
tearDownClass вызывается один раз после выполнения всех тестов и выводит результаты всех гонок.

Тест гонки между Усэйном и Ником:

def test_race_usain_and_nik(self):
    tournament = Tournament(90, self.runner1, self.runner3)
    results = tournament.start()
    for name, result in results.items():
        results[name] = result.name
    self.all_results[len(self.all_results) + 1] = results

    # Проверяем, что Ник всегда последний
    self.assertTrue(results[max(results.keys())] == "Ник")
Создается объект Tournament, который запускается с двумя бегунами (Усэйном и Ником). Результаты гонки сохраняются в all_results. Далее выполняется проверка, что Ник всегда последний.

Тест гонки между Андреем и Ником:

def test_race_andrey_and_nik(self):
    tournament = Tournament(90, self.runner2, self.runner3)
    results = tournament.start()
    for name, result in results.items():
        results[name] = result.name
    self.all_results[len(self.all_results) + 1] = results

    # Проверяем, что Ник всегда последний
    self.assertTrue(results[max(results.keys())] == "Ник")
Аналогично предыдущему тесту, но с бегунами Андрей и Ник.

Тест гонки между Усэйном, Андреем и Ником:

def test_race_usain_andrey_and_nik(self):
    tournament = Tournament(90, self.runner1, self.runner2, self.runner3)
    results = tournament.start()
    for name, result in results.items():
        results[name] = result.name
    self.all_results[len(self.all_results) + 1] = results

    # Проверяем, что Ник всегда последний
    self.assertTrue(results[max(results.keys())] == "Ник")
Здесь проверяется гонка между всеми тремя бегунами.

Запуск тестов:

if __name__ == '__main__':
    unittest.main()
Если файл запускается как основная программа, вызывается unittest.main(), который автоматически найдет и выполнит все тесты, определённые в классе.



Если Вы хотите использовать assertTrue и при этом не провалить тест, но вывести ошибку, можно использовать конструкцию try-except. Вот пример, как это сделать с помощью библиотеки unittest:

import unittest

class MyTestCase(unittest.TestCase):
    def test_example(self):
        try:
            self.assertTrue(False, "Это сообщение ошибки")
        except AssertionError as e:
            print(f"Тест не прошел: {e}")

if __name__ == '__main__':
    unittest.main()


В этом примере, если проверка assertTrue не проходит, возникнет исключение AssertionError, которое перехватится в блоке except. Вы можете вывести сообщение об ошибке, не завершая выполнение теста.

Однако в данном случае тест все равно будет считаться проваленным, так как Вы явно не пропустили вызов assert.

Если Ваша цель — просто вывести сообщение и не проваливать тест, Вы можете использовать self.fail():

import unittest

class MyTestCase(unittest.TestCase):
    def test_example(self):
        condition = False  # Здесь Ваше условие
        if not condition:
            print("Тест провалился, но продолжаем выполнение")
            self.fail("Условие не выполнено")
        else:
            # другие проверки, если нужно
            self.assertTrue(condition)

if __name__ == '__main__':
    unittest.main()
Таким образом, Вы можете контролировать логику теста, не завершая выполнение программы сразу при провале.
